#ifndef MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H
#define MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H

#include "marco/Codegen/Transforms/ModelSolving/Scheduling.h"
#include "marco/Dialect/Simulation/SimulationDialect.h"
#include "marco/VariableFilter/VariableFilter.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Pass/Pass.h"
#include <string>

namespace mlir::modelica::impl
{
  /// The purpose of this class is to generate the algorithmic functions that
  /// compose the simulation. The usage of such functions is delegated to the
  /// runtime library, which is statically linked with the code generated by
  /// the compiler. This decoupling allows to relieve the code generation phase
  /// from the generation of functions that are independent from the model
  /// being processed.
  class ModelSolver
  {
    public:
      ModelSolver();

      virtual ~ModelSolver();

      mlir::LogicalResult convert(
          ModelOp modelOp,
          const marco::VariableFilter& variablesFilter,
          bool processICModel = true,
          bool processMainModel = true);

      mlir::LogicalResult legalizeFuncOps(
          mlir::ModuleOp moduleOp,
          mlir::TypeConverter& typeConverter) const;

    private:
      mlir::simulation::ModuleOp createSimulationModule(
          mlir::OpBuilder& builder,
          ModelOp modelOp,
          const marco::codegen::DerivativesMap& derivativesMap,
          const marco::VariableFilter& variablesFilter);

      marco::modeling::IndexSet getPrintableIndices(
          ModelOp modelOp,
          const marco::codegen::DerivativesMap& derivativesMap,
          const marco::VariableFilter& variablesFilter,
          VariableOp variableOp) const;

      /// Create the initialization function that allocates the variables and
      /// stores them into an appropriate data structure to be passed to the
      /// other simulation functions.
      mlir::LogicalResult createInitFunction(
          mlir::OpBuilder& builder,
          mlir::modelica::ModelOp modelOp,
          mlir::simulation::ModuleOp simulationModuleOp) const;

      /// Create a function to be called when the simulation has finished and
      /// the variables together with its data structure are not required
      /// anymore and thus can be deallocated.
      mlir::LogicalResult createDeinitFunction(
          mlir::OpBuilder& builder,
          mlir::modelica::ModelOp modelOp,
          mlir::simulation::ModuleOp simulationModuleOp) const;

      mlir::LogicalResult createVariableGetterFunctions(
          mlir::OpBuilder& builder,
          mlir::modelica::ModelOp modelOp,
          mlir::simulation::ModuleOp simulationModuleOp) const;

    protected:
      /// Convert the initial scheduled model into the algorithmic functions
      /// used to determine the initial values of the simulation.
      virtual mlir::LogicalResult solveICModel(
          mlir::OpBuilder& builder,
          mlir::simulation::ModuleOp simulationModuleOp,
          const marco::codegen::Model<
              marco::codegen::ScheduledEquationsBlock>& model) = 0;

      /// Convert the main scheduled model into the algorithmic functions that
      /// compose the simulation.
      virtual mlir::LogicalResult solveMainModel(
          mlir::OpBuilder& builder,
          mlir::simulation::ModuleOp simulationModuleOp,
          const marco::codegen::Model<
              marco::codegen::ScheduledEquationsBlock>& model) = 0;
  };
}

namespace mlir::modelica
{
#define GEN_PASS_DECL_MODELCONVERSIONTESTPASS
#include "marco/Codegen/Transforms/Passes.h.inc"

  std::unique_ptr<mlir::Pass> createModelConversionTestPass();

  std::unique_ptr<mlir::Pass> createModelConversionTestPass(
      const ModelConversionTestPassOptions& options);
}

#endif // MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H
