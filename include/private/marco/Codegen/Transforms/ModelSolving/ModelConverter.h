#ifndef MARCO_CODEGEN_TRANSFORMS_MODELSOLVING_MODELCONVERTER_H
#define MARCO_CODEGEN_TRANSFORMS_MODELSOLVING_MODELCONVERTER_H

#include "marco/Codegen/Conversion/ModelicaCommon/TypeConverter.h"
#include "marco/Codegen/Transforms/ModelSolving/ExternalSolvers/ExternalSolver.h"
#include "marco/Codegen/Transforms/ModelSolving/ExternalSolvers/IDAOptions.h"
#include "marco/Codegen/Transforms/ModelSolving/Scheduling.h"
#include "marco/Codegen/Transforms/ModelSolving/Solver.h"
#include "marco/Dialect/Modelica/ModelicaDialect.h"
#include "marco/VariableFilter/VariableFilter.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "llvm/ADT/StringRef.h"
#include <map>
#include <set>

namespace marco::codegen
{
  /// The purpose of this class is to generate the algorithmic functions that compose the simulation.
  /// The usage of such functions is delegated to the runtime library, which is statically linked
  /// with the code generated by the compiler. This decoupling allows to relieve the code generation
  /// phase from the generation of functions that are independent from the model being processed.
  class ModelConverter
  {
    public:
      // Name for the functions of the simulation
      static constexpr llvm::StringLiteral getModelNameFunctionName = "getModelName";
      static constexpr llvm::StringLiteral getNumOfVariablesFunctionName = "getNumOfVariables";
      static constexpr llvm::StringLiteral getVariableNameFunctionName = "getVariableName";
      static constexpr llvm::StringLiteral getVariableRankFunctionName = "getVariableRank";
      static constexpr llvm::StringLiteral getVariableNumOfPrintableRangesFunctionName = "getVariableNumOfPrintableRanges";
      static constexpr llvm::StringLiteral getVariablePrintableRangeBeginFunctionName = "getVariablePrintableRangeBegin";
      static constexpr llvm::StringLiteral getVariablePrintableRangeEndFunctionName = "getVariablePrintableRangeEnd";
      static constexpr llvm::StringLiteral getVariableValueFunctionName = "getVariableValue";
      static constexpr llvm::StringLiteral getDerivativeFunctionName = "getDerivative";
      static constexpr llvm::StringLiteral getCurrentTimeFunctionName = "getCurrentTime";
      static constexpr llvm::StringLiteral mainFunctionName = "main";
      static constexpr llvm::StringLiteral initFunctionName = "init";
      static constexpr llvm::StringLiteral initICSolversFunctionName = "initICSolvers";
      static constexpr llvm::StringLiteral deinitICSolversFunctionName = "deinitICSolvers";
      static constexpr llvm::StringLiteral calcICFunctionName = "calcIC";
      static constexpr llvm::StringLiteral initMainSolversFunctionName = "initMainSolvers";
      static constexpr llvm::StringLiteral deinitMainSolversFunctionName = "deinitMainSolvers";
      static constexpr llvm::StringLiteral updateNonStateVariablesFunctionName = "updateNonStateVariables";
      static constexpr llvm::StringLiteral updateStateVariablesFunctionName = "updateStateVariables";
      static constexpr llvm::StringLiteral incrementTimeFunctionName = "incrementTime";
      static constexpr llvm::StringLiteral printHeaderFunctionName = "printHeader";
      static constexpr llvm::StringLiteral printFunctionName = "print";
      static constexpr llvm::StringLiteral deinitFunctionName = "deinit";
      static constexpr llvm::StringLiteral runFunctionName = "runSimulation";

    private:
      static constexpr size_t externalSolversPosition = 0;
      static constexpr size_t timeVariablePosition = 1;
      static constexpr size_t variablesOffset = 2;

      struct ConversionInfo
      {
        std::set<std::unique_ptr<Equation>> explicitEquations;
        std::map<ScheduledEquation*, Equation*> explicitEquationsMap;
        std::set<ScheduledEquation*> implicitEquations;
        std::set<ScheduledEquation*> cyclicEquations;
      };

    public:
      ModelConverter(
          mlir::LLVMTypeConverter& typeConverter,
          VariableFilter& variablesFilter,
          Solver solver,
          double startTime,
          double endTime,
          double timeStep,
          IDAOptions idaOptions);

      /// Create the function to be called to retrieve the name of the
      /// compiled model.
      mlir::LogicalResult createGetModelNameFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the function to be called to retrieve the number of variables
      /// of the compiled model.
      mlir::LogicalResult createGetNumOfVariablesFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the function to be called to retrieve the name of variables of
      /// the compiled model.
      mlir::LogicalResult createGetVariableNameFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the function to be called to retrieve the name of variables of
      /// the compiled model.
      mlir::LogicalResult createGetVariableRankFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the function to be called to retrieve the number of printable
      /// indices ranges for a given variable.
      mlir::LogicalResult createGetVariableNumOfPrintableRangesFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp, const DerivativesMap& derivativesMap) const;

      /// Create the function to be called to retrieve the begin index of a
      /// printable range for a given variable and dimension.
      mlir::LogicalResult createGetVariablePrintableRangeBeginFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp, const DerivativesMap& derivativesMap) const;

      /// Create the function to be called to retrieve the end index of a
      /// printable range for a given variable and dimension.
      mlir::LogicalResult createGetVariablePrintableRangeEndFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp, const DerivativesMap& derivativesMap) const;

      /// Create the function to be called to retrieve the value of a scalar
      /// variable.
      mlir::LogicalResult createGetVariableValueFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the function to be called to retrieve the index of the
      /// derivative of a variable.
      mlir::LogicalResult createGetDerivativeFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp, const DerivativesMap& derivativesMap) const;

      /// Create the function to be called to retrieve the current time of the
      /// simulation.
      mlir::LogicalResult createGetCurrentTimeFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the initialization function that allocates the variables and
      /// stores them into an appropriate data structure to be passed to the other
      /// simulation functions.
      mlir::LogicalResult createInitFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create a function to be called when the simulation has finished and the
      /// variables together with its data structure are not required anymore and
      /// thus can be deallocated.
      mlir::LogicalResult createDeinitFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Create the main function, which is called when the executable of the simulation is run.
      /// In order to keep the code generation simpler, the real implementation of the function
      /// managing the simulation lives within the runtime library and the main just consists in
      /// a call to such function.
      mlir::LogicalResult createMainFunction(mlir::OpBuilder& builder, mlir::modelica::ModelOp modelOp) const;

      /// Convert the initial scheduled model into the algorithmic functions used to determine the
      /// initial values of the simulation.
      mlir::LogicalResult convertInitialModel(mlir::OpBuilder& builder, const Model<ScheduledEquationsBlock>& model) const;

      /// Convert the main scheduled model into the algorithmic functions that compose the simulation.
      mlir::LogicalResult convertMainModel(mlir::OpBuilder& builder, const Model<ScheduledEquationsBlock>& model) const;

    private:
      /// Get the MLIR type corresponding to void*.
      mlir::Type getVoidPtrType() const;

      /// Get the function to be used to allocate heap memory.
      mlir::LLVM::LLVMFuncOp lookupOrCreateHeapAllocFn(mlir::OpBuilder& builder, mlir::ModuleOp module) const;

      /// Get the function to be used to deallocate heap memory.
      mlir::LLVM::LLVMFuncOp lookupOrCreateHeapFreeFn(mlir::OpBuilder& builder, mlir::ModuleOp module) const;

      /// Allocate some data on the heap.
      mlir::Value alloc(mlir::OpBuilder& builder, mlir::ModuleOp module, mlir::Location loc, mlir::Type type) const;

      mlir::LLVM::LLVMStructType getRuntimeDataStructType(
          mlir::MLIRContext* context, mlir::TypeRange varTypes) const;

      mlir::LLVM::LLVMStructType getExternalSolversStructType(
          mlir::MLIRContext* context, const ExternalSolvers& externalSolvers) const;

      /// Load the data structure from the opaque pointer that is passed around the
      /// simulation functions.
      ///
      /// @param builder	    operation builder
      /// @param ptr 	        opaque pointer
      /// @param runtimeData  type of the runtime data structure
      /// @return data structure containing the variables
      mlir::Value loadDataFromOpaquePtr(
          mlir::OpBuilder& builder, mlir::Value ptr, mlir::LLVM::LLVMStructType runtimeData) const;

      /// Extract a value from the data structure shared between the various
      /// simulation main functions.
      mlir::Value extractValue(
          mlir::OpBuilder& builder,
          mlir::Value structValue,
          mlir::Type type,
          unsigned int position) const;

      /// Allocate the structure needed by each solver and the wrapping structure containing their addresses.
      mlir::Value createExternalSolvers(
          mlir::OpBuilder& builder,
          mlir::ModuleOp module,
          mlir::Location loc,
          const ExternalSolvers& externalSolvers) const;

      /// Bufferize the variables and convert the subsequent load/store operations to operate on the
      /// allocated memory buffer.
      mlir::Value convertMember(mlir::OpBuilder& builder, mlir::modelica::MemberCreateOp op) const;

      /// Create the function that instantiates the external solvers.
      mlir::LogicalResult createInitSolversFunction(
          mlir::OpBuilder& builder,
          llvm::StringRef functionName,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that deallocates the external solvers.
      mlir::LogicalResult createDeinitSolversFunction(
          mlir::OpBuilder& builder,
          llvm::StringRef functionName,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that instantiates the external solvers to be used during the IC computation.
      mlir::LogicalResult createInitICSolversFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that computes the initial conditions.
      mlir::LogicalResult createCalcICFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ConversionInfo& conversionInfo,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that deallocates the external solvers used during the IC computation.
      mlir::LogicalResult createDeinitICSolversFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that instantiates the external solvers to be used during the simulation.
      mlir::LogicalResult createInitMainSolversFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      /// Create the function that deallocates the external solvers used during the simulation.
      mlir::LogicalResult createDeinitMainSolversFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ExternalSolvers& externalSolvers) const;

      mlir::func::FuncOp createEquationFunction(
          mlir::OpBuilder& builder,
          const ScheduledEquation& equation,
          llvm::StringRef equationFunctionName,
          mlir::func::FuncOp templateFunction,
          std::multimap<mlir::func::FuncOp, mlir::func::CallOp>& equationTemplateCalls,
          mlir::TypeRange varsTypes) const;

      mlir::LogicalResult createUpdateNonStateVariablesFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          const ConversionInfo& conversionInfo,
          ExternalSolvers& externalSolvers) const;

      /// Create the functions that calculates the values that the state variables will have
      /// in the next iteration.
      mlir::LogicalResult createUpdateStateVariablesFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          ExternalSolvers& externalSolvers) const;

      mlir::LogicalResult createIncrementTimeFunction(
          mlir::OpBuilder& builder,
          const Model<ScheduledEquationsBlock>& model,
          ExternalSolvers& externalSolvers) const;

      mlir::Value getOrCreateGlobalString(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          mlir::ModuleOp module,
          mlir::StringRef name,
          mlir::StringRef value) const;

      mlir::LogicalResult createGetVariablePrintableRangeBoundariesFunction(
          mlir::OpBuilder& builder,
          mlir::modelica::ModelOp modelOp,
          const DerivativesMap& derivativesMap,
          llvm::StringRef functionName,
          std::function<int64_t(const modeling::Range&)> boundaryGetterCallback) const;

      mlir::LogicalResult createGetPrintableIndexSetBoundariesFunction(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          mlir::ModuleOp module,
          llvm::StringRef functionName,
          const modeling::IndexSet& indexSet,
          std::function<int64_t(const modeling::Range&)> boundaryGetterCallback,
          std::map<unsigned int, std::map<modeling::MultidimensionalRange, mlir::func::FuncOp>>& rangeBoundaryFuncOps,
          llvm::StringRef baseRangeFunctionName,
          size_t& rangeFunctionsCounter) const;

      mlir::func::FuncOp createGetPrintableMultidimensionalRangeBoundariesFunction(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          mlir::ModuleOp module,
          llvm::StringRef functionName,
          const modeling::MultidimensionalRange& ranges,
          std::function<int64_t(const modeling::Range&)> boundaryGetterCallback) const;

      mlir::func::FuncOp createScalarVariableGetter(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          mlir::ModuleOp module,
          llvm::StringRef functionName,
          mlir::modelica::ArrayType arrayType) const;

    private:
      mlir::LLVMTypeConverter* typeConverter;
      VariableFilter* variablesFilter;
      Solver solver;
      double startTime;
      double endTime;
      double timeStep;
      IDAOptions idaOptions;
  };
}

#endif // MARCO_CODEGEN_TRANSFORMS_MODELSOLVING_MODELCONVERTER_H
