#ifndef MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H
#define MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H

#include "marco/Dialect/Modelica/ModelicaDialect.h"
#include "marco/Dialect/Simulation/SimulationDialect.h"
#include "marco/Codegen/Analysis/DerivativesMap.h"
#include "marco/VariableFilter/VariableFilter.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Conversion/LLVMCommon/TypeConverter.h"
#include "mlir/Pass/Pass.h"
#include <string>

namespace mlir::modelica::impl
{
  /// The purpose of this class is to generate the algorithmic functions that
  /// compose the simulation. The usage of such functions is delegated to the
  /// runtime library, which is statically linked with the code generated by
  /// the compiler. This decoupling allows to relieve the code generation phase
  /// from the generation of functions that are independent from the model
  /// being processed.
  class ModelSolver
  {
    public:
      ModelSolver();

      virtual ~ModelSolver();

      mlir::LogicalResult convert(
          ModelOp modelOp,
          const DerivativesMap& derivativesMap,
          const marco::VariableFilter& variablesFilter,
          bool processICModel = true,
          bool processMainModel = true);

    private:
      mlir::LogicalResult createModelNameOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          ModelOp modelOp);

      mlir::LogicalResult createNumOfVariablesOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps);

      mlir::LogicalResult createVariableNamesOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps);

      mlir::LogicalResult createVariableRanksOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps);

      mlir::LogicalResult createPrintableIndicesOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps,
          const DerivativesMap& derivativesMap,
          const marco::VariableFilter& variablesFilter);

      mlir::LogicalResult createDerivativesMapOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps,
          const DerivativesMap& derivativesMap);

      mlir::LogicalResult createGlobalVariables(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::SymbolTableCollection& symbolTableCollection,
          ModelOp modelOp,
          llvm::ArrayRef<VariableOp> variableOps,
          llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap);

      mlir::LogicalResult createVariableGetters(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          llvm::ArrayRef<VariableOp> variableOps,
          const llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap);

      /// Create the function that is called before starting the simulation.
      mlir::LogicalResult createInitFunction(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::modelica::ModelOp modelOp,
          llvm::ArrayRef<VariableOp> variableOps,
          const llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap);

      /// Create the function that is called when the simulation has finished.
      mlir::LogicalResult createDeinitFunction(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc);

      GlobalVariableOp declareTimeVariable(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::Location loc,
          mlir::SymbolTableCollection& symbolTableCollection);

      mlir::LogicalResult createTimeGetterOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::SymbolTableCollection& symbolTableCollection,
          GlobalVariableOp timeVariableOp);

      mlir::LogicalResult createTimeSetterOp(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::SymbolTableCollection& symbolTableCollection,
          GlobalVariableOp timeVariableOp);

      mlir::LogicalResult convertTimeOp(mlir::ModuleOp moduleOp);

    protected:
      /// Convert the initial scheduled model into the algorithmic functions
      /// used to determine the initial values of the simulation.
      virtual mlir::LogicalResult solveICModel(
          mlir::IRRewriter& rewriter,
          mlir::SymbolTableCollection& symbolTableCollection,
          mlir::modelica::ModelOp modelOp,
          llvm::ArrayRef<VariableOp> variableOps,
          const llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap,
          llvm::ArrayRef<SCCOp> SCCs) = 0;

      /// Convert the main scheduled model into the algorithmic functions that
      /// compose the simulation.
      virtual mlir::LogicalResult solveMainModel(
          mlir::IRRewriter& rewriter,
          mlir::SymbolTableCollection& symbolTableCollection,
          mlir::modelica::ModelOp modelOp,
          llvm::ArrayRef<VariableOp> variableOps,
          const DerivativesMap& derivativesMap,
          const llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap,
          llvm::ArrayRef<SCCOp> SCCs) = 0;

      /// Count how many instances do exist of each equation template.
      void getEquationTemplatesUsageCount(
          llvm::ArrayRef<SCCOp> SCCs,
          llvm::DenseMap<EquationTemplateOp, size_t>& usages) const;

      RawFunctionOp createEquationTemplateFunction(
          mlir::OpBuilder& builder,
          mlir::ModuleOp moduleOp,
          mlir::SymbolTableCollection& symbolTableCollection,
          EquationTemplateOp equationTemplateOp,
          uint64_t viewElementIndex,
          mlir::ArrayAttr iterationDirections,
          llvm::StringRef functionName,
          const llvm::StringMap<GlobalVariableOp>& localToGlobalVariablesMap);

    private:
      void createIterationLoops(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          llvm::ArrayRef<mlir::Value> beginIndices,
          llvm::ArrayRef<mlir::Value> endIndices,
          llvm::ArrayRef<mlir::Value> steps,
          mlir::ArrayAttr iterationDirections,
          llvm::SmallVectorImpl<mlir::Value>& inductions);

    protected:
      mlir::LogicalResult callEquationFunction(
          mlir::OpBuilder& builder,
          mlir::Location loc,
          ScheduledEquationInstanceOp equationOp,
          RawFunctionOp rawFunctionOp) const;
  };
}

namespace mlir::modelica
{
#define GEN_PASS_DECL_MODELCONVERSIONTESTPASS
#include "marco/Codegen/Transforms/Passes.h.inc"

  std::unique_ptr<mlir::Pass> createModelConversionTestPass();

  std::unique_ptr<mlir::Pass> createModelConversionTestPass(
      const ModelConversionTestPassOptions& options);
}

#endif // MARCO_CODEGEN_TRANSFORMS_SOLVERPASSBASE_H
